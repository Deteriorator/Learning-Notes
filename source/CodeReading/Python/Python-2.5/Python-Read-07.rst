##############################################################################
Python 源码阅读系列 7
##############################################################################

.. contents::

******************************************************************************
第 5 章  Python 中的 Dict 对象
******************************************************************************

元素和元素之间通常可能存在某种联系 ， 这种联系是本来好不相关的两个元素被捆绑在一起 ，\
而别的元素则被排斥在外 。 为了刻画这种对应关系 ， 现代编程语言通常都在语言级或标准库\
中提供某种关联式的容器 。 关联式的容器中存储着一对对符合该容器所代表的关联规则的元素\
对 。 其中的元素通常是以键 (key) 或值 (value) 的形式存在 。 

关联容器的设计总会极大地关注键的搜索效率 ， 因为通常使用关联容器都是希望根据手中已有\
的某个元素来快速获得与之有关系的另一个元素 。 一般而言 ， 关联容器的实现都会基于设计\
良好的数据结构 。 如 C++ 的 STL 中的 map 就是一种关联容器 ， map 的实现基于 \
RB-tree (红黑树) 。 RB-tree 是一种平衡二元树 ， 能提供良好的搜索效率 ， 理论上搜索\
时间复杂度为 O(logN) 。 

Python 提供了关联式容器 ， 即 PyDictObject 对象 (也称 dict) 。 与 map 不同的是 \
， PyDictObject 对搜索的效率要求极其苛刻 ， 这也是因为 PyDictObject 对象在 Python \
本身的实现中被大量采用 。 如 Python 会通过 PyDictObject 来建立执行 Python 字节码的\
运行环境 ， 其中会存放变量名和变量值的元素对 ， 通过查找变量名获得变量值 。 因此 ， \
PyDictObject 没有如 map 一样采用平衡二元树 ， 而是采用了散列表 (hash table) ， 因\
此理论上 ， 在最优情况下 ， 散列表能提供 O(1) 复杂度的搜索效率 。 

5.1 散列表概述
==============================================================================

散列表是通过一定的函数将需搜索的键值映射为一个整数 ， 将这个整数视为索引值去访问某片\
连续的内存区域 。 例如 ， 有 10 个整数 1 ， 2 ， ... ， 10 ， 其依次对应 a ， b \
， ... ， j 。 申请一块连续内存 ， 并依次存储 a ， b ， ... ， j ：

.. image:: img/5-1.png

当需要寻找与 2 对应的字母时 ， 只需通过一定的函数将其映射为整数 ， 可以使用这样的映\
射函数 f(n) = n ， 那么 2 的映射值就是 2 。 然后访问这片连续内存的第二个位置 ， 就\
能得到与 2 对应的字母 b 。 

对散列表这种数据结构的采用是以加速键的搜索过程为终极目标的 ， 于是将原始映射为整数\
的过程对于 Python 中 dict 的实现就显得尤为关键 。 用于映射的函数称为散列函数 \
(hash function) ， 而映射后的值称为元素的散列值 (hash value) 。 在散列表的实现\
中 ， 所选择的散列函数的优劣将直接决定所实现的散列表的搜索笑了的高低 。 

在使用散列表的过程中 ， 不同的对象经过散列函数的作用 ， 可能被映射为相同的散列值 \
。 而且随着需要存储的数据的增多 ， 这样的冲突就会发生得越来越频繁 。 散列冲突是散\
列技术与生俱来的问题 。 这里需要提到散列表中与散列冲突相关的概念 -- 装载率 。 装载\
率是散列表中已使用空间和总空间的比值 。 如果散列表一共可以容纳 10 个元素 ， 而当前\
已经装入了 6 个元素 ， 那么装载率就是 6/10 。 研究表明 ， 当散列表的装载率大于 \
2/3 时 ， 散列冲突发生得概率就会大大增加 。 

解决散列冲突的方法 ： 开链法 ， 这是 SGI STL 中的 hash table 所采用的方法 ， 而 \
Python 中所采用的是开放定址法 。

当产生散列冲突时 ， Python 会通过一个二次探测函数 f ， 计算下一个候选位置 addr \
， 如果 addr 可用 ， 则可将待插入元素放到位置 addr ； 如果位置 addr 不可用 ， 则 \
Python 会再次使用探测函数 f ， 获得下一个候选位置 ， 如此不断探测总会找到一个可用\
位置 。

通过多次探测函数 f ， 从一个位置出发就可以一次到达多个位置 ， 这些位置就形成了一\
个 "冲突探测链" (或简称探测序列) 。 当需要删除某条探测链上的某个元素时 ， 问题就\
产生了 ， 假如这条链的首元素位置为 a ， 尾元素的位置为 c ， 现在需要删除中间的某\
个位置 b 上的元素 。 如果直接将位置 b 上的元素删除 ， 则会导致探测链的断裂 ， 造\
成严重后果 。 

因为想象一下 ， 在下次的搜索位置 c 的元素时 ， 会从位置 a 开始 ， 通过探测函数 \
， 沿着探测链一步一步向位置 c 靠近 ， 但是在到达位置 b 时 ， 发现这个位置上的元素\
不属于这个探测链 ， 因此探测函数会以为探测链到此结束 ， 导致不能到达位置 c ， 自然\
不能搜索到位置 c 上的元素 ， 所以结果是搜索失败 。 而实际上待搜索元素确实存在于散\
列表中 。

所以在采用开放定址的冲突解决策略的散列表中 ， 删除某条探测链上的元素时不能进行真正\
的删除 ， 而是进行一种 "伪删除" 操作 ， 必须要让该元素还存在于探测链上 ， 担当承前\
启后的重任 。 

5.2 PyDictObject
==============================================================================

5.2.1 关联容器的 entry
------------------------------------------------------------------------------

将关联容器中的一个 (键 ， 值) 元素对称为一个 entry 或 slot 。 在 Python 中一个 \
entry 的定义如下 ：

.. code-block:: c 

    [Include/dictobject.h]

    typedef struct {
        /* Cached hash code of me_key.  Note that hash codes are C longs.
        * We have to use Py_ssize_t instead because dict_popitem() abuses
        * me_hash to hold a search finger.
        */
        Py_ssize_t me_hash;
        PyObject *me_key;
        PyObject *me_value;
    } PyDictEntry;

可以看到 ， 在 PyDictObject 中确实存放的都是 PyObject* ， 这也是 Python 中的 \
dict 什么都能装得下的原因 ， 因为在 Python 中 ， 无论什么东西归根结底都是一个 \
PyObject 对象 。 

未完待续 ...