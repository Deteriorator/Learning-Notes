*******************************************************************************
Part 07 - 附录： 替代碰撞处理
*******************************************************************************

.. contents:: 目录

处理哈希表中的冲突有两种常用方法： 

- 分离链
- 开放寻址

7.1 - 分离链
===============================================================================

在独立链下， 每个桶包含一个链接列表。 当条目发生碰撞时， 它们被添加到列表中。 方法:

- 插入： 通过哈希键来获得桶的索引。 如果该桶中没有任何东西， 则将条目存储在那里。 如\
  果那里已经有一个条目， 就把这个条目追加到链接列表中。 
- 搜索： 通过哈希键得到桶的索引。 遍历链表， 将每个条目的键与搜索键进行比较。 如果找\
  到该键， 返回该值， 否则返回 ``NULL``。 
- 删除： 通过哈希键获得桶的索引。 遍历链接列表， 比较每个条目的键和删除键。 如果找到\
  该键， 从链表中删除该条目。 如果链表中只有一个条目， 将 ``NULL`` 指针放入桶中， 以\
  表示它是空的。 

这样做的好处是实现起来很简单， 但空间效率很低。 每个条目都必须存储一个指向链表中下一\
个条目的指针， 如果后面没有条目， 则存储 ``NULL`` 指针。 这是浪费在记账上的空间， 这\
些空间可以用来存储更多的条目。

7.2 - 开放寻址
===============================================================================

开放寻址旨在解决单独链接的空间效率低下的问题。 当发生碰撞时， 碰撞的条目被放置在表中\
的其他某个桶中。 条目放入的桶是根据一些预先确定的规则选择的， 在搜索条目时可以重复。 \
选择要插入碰撞物品的桶有三种常用方法。 

7.2.1 - 线性探测
-------------------------------------------------------------------------------

当发生冲突时， 索引会递增， 并将条目放入数组中的下一个可用桶中。 方法： 

- 插入： 哈希键以找到桶索引。 如果桶是空的， 将条目插入那里。 如果不为空， 则重复递增\
  索引直到找到一个空桶， 然后将其插入那里。 
- 搜索： 哈希键以找到桶索引。 重复递增索引， 将每个条目的键与搜索键进行比较， 直到找\
  到一个空桶。 如果找到具有匹配键的条目， 则返回值， 否则返回 ``NULL``。 
- 删除： 哈希键以找到桶索引。 重复递增索引， 将每个条目的键与删除键进行比较， 直到找\
  到一个空桶。 如果找到具有匹配键的条目， 则将其删除。 删除这个条目会破坏链， 所以我\
  们别无选择， 只能在删除的条目之后重新插入链中的所有条目。 

线性探测提供了良好的 `缓存性能`_， 但存在聚类问题。 将碰撞的条目放在下一个可用的桶中\
可能会导致填充桶的长连续延伸， 在插入、 搜索或删除时需要对其进行迭代。 

.. _缓存性能: https://en.wikipedia.org/wiki/Locality_of_reference

7.2.2 - 二次探查
-------------------------------------------------------------------------------

类似于线性探测， 但不是将碰撞的条目放在下一个可用的桶中， 而是尝试将其放在索引遵循以\
下序列的桶中： ``i, i + 1, i + 4, i + 9, i + 16, ...``， 其中 ``i`` 是 Key 的原\
始哈希值。 方法： 

- 插入： 哈希键以找到桶索引。 按照探测顺序， 直到找到空或已删除的存储桶， 然后在那里\
  插入条目。
- 搜索： 哈希键以找到桶索引。 按照探测顺序， 将每个条目的键与搜索键进行比较， 直到找\
  到一个空桶。 如果找到匹配的键， 则返回值， 否则返回 ``NULL``。 
- 删除： 我们无法判断要删除的条目是否是碰撞链的一部分， 因此我们无法彻底删除该条目。 \
  相反， 我们只是将其标记为已删除。 

Quadratic probing 减少了但不会移除集群， 并且仍然提供不错的缓存性能。 

7.2.3 - 双重哈希
-------------------------------------------------------------------------------

双重哈希旨在解决聚类问题。 为此我们使用第二个哈希函数为条目选择新索引。 使用散列函数\
为我们提供了一个新的桶， 它的索引应该均匀地分布在所有的桶中。 这消除了聚类， 但也消除\
了参考位置的任何提升的缓存性能。 双重哈希是生产哈希表中常见的冲突管理方法， 也是我们\
在本教程中实现的方法。 
