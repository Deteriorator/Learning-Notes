##############################################################################
Python Web 模块之 Flask v0.1
##############################################################################

.. contents::

******************************************************************************
第 1 部分  源码阅读环境 
******************************************************************************

1.1 下载源码
==============================================================================

首先从 github 上 clone 源码仓库 ： 

.. code-block:: bash

    git clone https://github.com/pallets/flask.git
    git checkout 0.1

1.2 Python 环境
==============================================================================

我一般使用 Anaconda 进行 Python 虚拟环境管理 ， 因此使用 Anaconda 创建一个 \
Python 2.7 环境 ， 然后激活该环境 ， 并在命令行中执行 ：

.. code-block:: bash

    pip install -i https://pypi.douban.com/simple -r requirements.txt 

这个 requirements.txt 文件中是 flask 0.1 版本依赖的两个模块 。 

1.3 本地上下文
==============================================================================

在多线程环境下 ， 要想让所有视图函数都获取请求对象 。 最直接的方法就是在调用视图函数\
时将所有需要的数据作为参数传递进去 ， 但这样一来程序逻辑就变得冗余且不易于维护 。 另\
一种方法是将这些数据设为全局变量 ， 但是如果直接将请求对象设为全局变量 ， 那么必然会\
在不同的线程中导致混乱 （非线程安全） 。 本地线程 （thread locals） 的出现解决了这\
些问题 。

本地线程就是一个全局对象 ， 你可以使用一种特定线程且线程安全的方式来存储和获取数据 \
。 也就是说 ， 同一个变量在不同的线程内拥有各自的值 ， 互不干扰 。 实现原理其实很简\
单 ， 就是根据线程的ID来存取数据 。 Flask 没有使用标准库的 threading.local() ， \
而是使用了 Werkzeug 自己实现的本地线程对象 werkzeug.local.Local() ， 后者增加了\
对 Greenlet 的优先支持 。 

Flask 使用本地线程来让上下文代理对象全局可访问 ， 比如 request 、 session 、 \
current_app 、 g ， 这些对象被称为本地上下文对象 （context locals） 。 因此 ， \
在不基于线程 、 greenlet 或单进程实现的并发服务器上 ， 这些代理对象将无法正常工作 \
， 但好在仅有少部分服务器不被支持 。 Flask 的设计初衷是为了让传统 Web 程序的开发更\
加简单和迅速 ， 而不是用来开发大型程序或异步服务器的 。 但是 Flask 的可扩展性却提供\
了无限的可能性 ， 除了使用扩展 ， 我们还可以子类化 Flask 类 ， 或是为程序添加中间\
件 。

