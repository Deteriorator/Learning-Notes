##############################################################################
C 语言实现哈希表
##############################################################################

.. contents::

******************************************************************************
05  哈希表方法
******************************************************************************

更新
==============================================================================

我们的哈希表目前不支持更新键的值 。 如果我们插入两个键相同的条 ， 键将发生冲突 ， 第\
二项将插入下一个可用的存储桶中 。 搜索 key 的时候 ， 总是会找到原来的 key ， 我们无\
法访问到第二项 。 

我们可以通过修改 ``ht_insert`` 来解决这个问题 ， 以删除前一个条目并在其位置插入新条\
目 。

.. code-block:: C 

    // hash_table.c
    void ht_insert(ht_hash_table* ht, const char* key, const char* value) {
        // ...
        while (cur_item != NULL) {
           if (cur_item != &HT_DELETED_ITEM) {
                if (strcmp(cur_item->key, key) == 0) {
                    ht_del_item(cur_item);
                    ht->items[index] = item;
                    return;
                }
            }
            // ...
        } 
        // ...
    }

下一节 : 调整表格大小

******************************************************************************
06  调整表格大小
******************************************************************************

目前 ， 我们的哈希表有固定数量的桶 。 随着更多条目的插入 ， 表格开始填满 。 这是有问\
题的 ， 原因有两个 ： 

1. 哈希表的性能随着高冲突率而降低
2. 我们的哈希表只能存储固定数量的条目 。 如果我们尝试存储更多 ， 插入功能将失败 。 

为了缓解这种情况 ， 我们可以在条目数组太满时增加它的大小 。 我们将存储在哈希表中的条\
目数存储在表的 ``count`` 属性中 。 在每次插入和删除时 ， 我们计算表的 "负载" ， 或\
已填充的桶与总桶的比率 。 如果它高于或低于某些值 ， 我们将向上或向下调整桶的大小 。 

我们将调整大小 ： 

- 增加 ， 如果负载 > 0.7
- 减少 ， 如果负载 < 0.1

为了调整大小 ， 我们创建一个新的哈希表 ， 大约是当前哈希表的一半或两倍 ， 并将所有未\
删除的条目插入其中 。 

我们的新数组大小应该是一个质数 ， 大约是当前大小的两倍或一半 。 找到新的数组大小并非\
易事 。 为此 ， 我们存储我们希望数组的基本大小 ， 然后将实际大小定义为第一个大于基本\
大小的素数 。 要调整大小 ， 我们将基本大小加倍 ， 并找到第一个较大的素数 ， 而要调整\
大小 ， 我们将大小减半并找到下一个较大的素数 。 

我们的基本大小从 50 开始 。 而不是存储

我们使用暴力方法通过检查每个连续数字是否为素数来找到下一个素数 。 虽然强制执行任何事\
情听起来令人震惊 ， 但我们实际需要检查的值的数量很少 ， 并且重新散列表中的每个条目所\
花费的时间超过了它所花费的时间 。 

首先 ， 让我们定义一个查找下一个素数的函数 。 我们将在两个新文件中执行此操作 ， 
``prime.h`` 和 ``prime.c`` 。 

.. code-block:: c

    // prime.h
    int is_prime(const int x);
    int next_prime(int x);

.. code-block:: c

    // prime.c

    #include <math.h>

    #include "prime.h"


    /*
    * Return whether x is prime or not
    *
    * Returns:
    *   1  - prime
    *   0  - not prime
    *   -1 - undefined (i.e. x < 2)
    */
    int is_prime(const int x) 
    {
        if (x < 2) 
        { 
            return -1; 
        }
        if (x < 4) 
        { 
            return 1; 
        }
        if ((x % 2) == 0) 
        { 
            return 0; 
        }
        for (int i = 3; i <= floor(sqrt((double) x)); i += 2) 
        {
            if ((x % i) == 0) 
            {
                return 0;
            }
        }
        return 1;
    }


    /*
    * Return the next prime after x, or x if x is prime
    */
    int next_prime(int x) 
    {
        while (is_prime(x) != 1) 
        {
            x++;
        }
        return x;
    }

接下来 ， 我们需要更新我们的 ``ht_new`` 函数以支持创建特定大小的哈希表 。 为此 ， 我\
们将创建一个新函数 ``ht_new_sized`` 。 我们将 ``ht_new`` 更改为使用默认起始大小调\
用 ``ht_new_size`` 。 

.. code-block:: C 

    // hash_table.c
    static ht_hash_table* ht_new_sized(const int base_size)
    {
        ht_hash_table* ht = xmalloc(sizeof(ht_hash_table));
        ht->base_size = base_size;

        ht->size = next_prime(ht->base_size);

        ht->count = 0;
        ht->items = xcalloc((size_t)ht->size, sizeof(ht_item*));
        return ht;
    }

    // hash_table.c
    ht_hash_table* ht_new()
    {
        return ht_new_sized(HT_INITIAL_BASE_SIZE);
    }

现在我们有了编写调整大小函数所需的所有部分 。 

在我们的 resize 函数中 ， 我们检查以确保我们没有试图将哈希表的大小减小到其最小值以\
下 。 然后我们初始化一个具有所需大小的新哈希表 。 所有非 ``NULL`` 或已删除的条目都\
被插入到新的哈希表中 。 然后我们在删除旧哈希表之前交换新旧哈希表的属性 。 

.. code-block:: C 

    // hash_table.c
    static void ht_resize(ht_hash_table* ht, const int base_size) 
    {
        if (base_size < HT_INITIAL_BASE_SIZE)
        {
            return;
        }
        ht_hash_table* new_ht = ht_new_sized(base_size);
        for (int i = 0; i < ht->size; i++)
        {
            ht_item* item = ht->items[i];
            if (item != NULL && item != &HT_DELETED_ITEM)
            {
                ht_insert(new_ht, item->key, item->value);
            }
        }

        ht->base_size = new_ht->base_size;
        ht->count = new_ht->count;

        // To delete new_ht, we give it ht's size and items
        const int tmp_size = ht->size;
        ht->size = new_ht->size;
        new_ht->size = tmp_size;

        ht_item** tmp_items = ht->items;
        ht->items = new_ht->items;
        new_ht->items = tmp_items;

        ht_del_hash_table(new_ht);
    }

为了简化调整大小 ， 我们定义了两个用于调整大小的小函数 。 

.. code-block:: C 

    // hash_table.c
    static void ht_resize_up(ht_hash_table* ht)
    {
        const int new_size = ht->base_size * 2;
        ht_resize(ht, new_size);
    }


    static void ht_resize_down(ht_hash_table* ht)
    {
        const int new_size = ht->base_size / 2;
        ht_resize(ht, new_size);
    }

为了执行调整大小 ， 我们在插入和删除时检查哈希表上的负载 。 如果它高于或低于 0.7 和 \
0.1 的预定义限制 ， 我们将分别向上或向下调整大小 。 

为了避免进行浮点数学运算 ， 我们将计数乘以 100 ， 然后检查它是否高于或低于 70 或 \
10 。 

.. code-block:: C 

    // hash_table.c
    void ht_insert(ht_hash_table* ht, const char* key, const char* value) {
        const int load = ht->count * 100 / ht->size;
        if (load > 70) {
            ht_resize_up(ht);
        }
        // ...
    }


    void ht_delete(ht_hash_table* ht, const char* key) {
        const int load = ht->count * 100 / ht->size;
        if (load < 10) {
            ht_resize_down(ht);
        }
        // ...
    }

下一节 : 附录：替代碰撞处理

******************************************************************************
07  附录：替代碰撞处理
******************************************************************************

处理哈希表中的冲突有两种常用方法 ： 

- 分离链
- 开放寻址

分离链
==============================================================================

在独立链下 ， 每个桶包含一个链接列表 。 当条目发生碰撞时 ， 它们被添加到列表中 。 方\
法 :

- 插入 ： 通过哈希键来获得桶的索引 。 如果该桶中没有任何东西 ， 则将条目存储在那里 \
  。 如果那里已经有一个条目 ， 就把这个条目追加到链接列表中 。 
- 搜索 ： 通过哈希键得到桶的索引 。 遍历链表 ， 将每个条目的键与搜索键进行比较 。 如\
  果找到该键 ， 返回该值 ， 否则返回 ``NULL`` 。 
- 删除 ： 通过哈希键获得桶的索引 。 遍历链接列表 ， 比较每个条目的键和删除键 。 如果\
  找到该键 ， 从链表中删除该条目 。 如果链表中只有一个条目 ， 将 ``NULL`` 指针放入\
  桶中 ， 以表示它是空的 。 

这样做的好处是实现起来很简单 ， 但空间效率很低 。 每个条目都必须存储一个指向链表中下\
一个条目的指针 ， 如果后面没有条目 ， 则存储 ``NULL`` 指针 。 这是浪费在记账上的空\
间 ， 这些空间可以用来存储更多的条目 。

开放寻址
==============================================================================

开放寻址旨在解决单独链接的空间效率低下的问题 。 当发生碰撞时 ， 碰撞的条目被放置在表\
中的其他某个桶中 。 条目放入的桶是根据一些预先确定的规则选择的 ， 在搜索条目时可以重\
复 。 选择要插入碰撞物品的桶有三种常用方法 。 

线性探测
------------------------------------------------------------------------------

当发生冲突时 ， 索引会递增 ， 并将条目放入数组中的下一个可用桶中 。 方法 ： 

- 插入 ： 哈希键以找到桶索引 。 如果桶是空的 ， 将条目插入那里 。 如果不为空 ， 则重\
  复递增索引直到找到一个空桶 ， 然后将其插入那里 。 
- 搜索 ： 哈希键以找到桶索引 。 重复递增索引 ， 将每个条目的键与搜索键进行比较 ， 直\
  到找到一个空桶 。 如果找到具有匹配键的条目 ， 则返回值 ， 否则返回 ``NULL`` 。 
- 删除 ： 哈希键以找到桶索引 。 重复递增索引 ， 将每个条目的键与删除键进行比较 ， 直\
  到找到一个空桶 。 如果找到具有匹配键的条目 ， 则将其删除 。 删除这个条目会破坏链 \
  ， 所以我们别无选择 ， 只能在删除的条目之后重新插入链中的所有条目 。 

线性探测提供了良好的 缓存性能_ ， 但存在聚类问题 。 将碰撞的条目放在下一个可用的桶中\
可能会导致填充桶的长连续延伸 ， 在插入 、 搜索或删除时需要对其进行迭代 。 

.. _缓存性能: https://en.wikipedia.org/wiki/Locality_of_reference

二次探查
------------------------------------------------------------------------------

类似于线性探测 ， 但不是将碰撞的条目放在下一个可用的桶中 ， 而是尝试将其放在索引遵循\
以下序列的桶中 ： ``i, i + 1, i + 4, i + 9, i + 16, ...`` ， 其中 ``i`` 是 Key \
的原始哈希值 。 方法 ： 

- 插入 ： 哈希键以找到桶索引 。 按照探测顺序 ， 直到找到空或已删除的存储桶 ， 然后在\
  那里插入条目 。
- 搜索 ： 哈希键以找到桶索引 。 按照探测顺序 ， 将每个条目的键与搜索键进行比较 ， 直\
  到找到一个空桶 。 如果找到匹配的键 ， 则返回值 ， 否则返回 ``NULL`` 。 
- 删除 ： 我们无法判断要删除的条目是否是碰撞链的一部分 ， 因此我们无法彻底删除该条目 \
  。 相反 ， 我们只是将其标记为已删除 。 

Quadratic probing 减少了但不会移除集群 ， 并且仍然提供不错的缓存性能 。 

双重哈希
------------------------------------------------------------------------------

双重哈希旨在解决聚类问题 。 为此 ， 我们使用第二个哈希函数为条目选择新索引 。 使用散\
列函数为我们提供了一个新的桶 ， 它的索引应该均匀地分布在所有的桶中 。 这消除了聚类 ， \
但也消除了参考位置的任何提升的缓存性能 。 双重哈希是生产哈希表中常见的冲突管理方法 ， \
也是我们在本教程中实现的方法 。 



