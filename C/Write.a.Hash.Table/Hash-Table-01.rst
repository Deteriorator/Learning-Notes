##############################################################################
C 语言实现哈希表
##############################################################################

源文件参考 ： https://github.com/jamesroutley/write-a-hash-table

本教程由 `James Routley`_ 撰写 ， 是他在 routley.io 上发表的博客 。 本人学习过程中将\
其用中文记录下来 。 

.. _`James Routley`: https://twitter.com/james_routley

哈希表_ 是最有用的数据结构之一 。 它们快速 ， 可扩展的插入 ， 搜索和删除功能使它们与\
大量计算机科学问题相关 。 

.. _哈希表: https://en.wikipedia.org/wiki/Hash_table

在本教程中 ， 我们将使用 C 语言实现一个开放地址的双散列表 。 通过学习本教程 ， 您将\
获得 ： 

- 了解基本数据结构如何在后台运行
- 深入了解何时使用哈希表 ， 何时不使用哈希表 ， 以及哈希表会如何失效
- 接触新的 C 代码

C 是一种编写哈希表的好语言 ， 因为 ： 

- 这种语言不包含任何一种
- 它是一种低级别的语言，因此你可以更深入地了解事物在机器层面的工作方式

本教程假定您对编程和 C 语法有一定的了解 。 代码本身相对简单明了 ， 大多数问题都可以\
通过网络搜索解决 。 如果您遇到其他问题 ， 请打开 GitHub Issue_ 。

.. _Issue: https://github.com/jamesroutley/write-a-hash-table/issues

完整的实现大约需要 200 行代码 ， 大约需要一两个小时才能完成 。 

**目录结构**

1. `简介`_
2. `哈希表结构`_
3. `哈希函数`_
4. `处理碰撞`_
5. `哈希表方法`_
6. `调整表格大小`_
7. `附录：替代碰撞处理`_

.. _`简介`: #id15
.. _`哈希表结构`:
.. _`哈希函数`:
.. _`处理碰撞`:
.. _`哈希表方法`:
.. _`调整表格大小`:
.. _`附录：替代碰撞处理`:

.. contents::

******************************************************************************
01  简介
******************************************************************************

哈希表是一种数据结构 ， 它提供了 `关联数组 API`_ 的快速实现 。 由于有关哈希表的术语\
可能令人困惑 ， 因此我在下面添加了一个 摘要_ 。

.. _`关联数组 API`: #id16
.. _摘要: #id19

哈希表由一组 "桶" 组成 ， 每个桶存储一个键值对 。 为了定位应该存储键值对的桶 ， 键被\
传递给一个散列函数 。 此函数返回一个整数 ， 用作存储桶数组中该对的索引 。 当我们想要\
检索一个键值对时 ， 我们将键提供给同一个散列函数 ， 接收它的索引 ， 并使用索引在数组\
中找到它 。 

数组索引的算法复杂度为 O(1) ， 这使得哈希表在存储和检索数据时速度很快 。

我们的哈希表将字符串键映射到字符串值 ， 但这里给出的原则适用于将任意键类型映射到任意\
值类型的哈希表 。 仅支持 ASCII 字符串 ， 因为支持 unicode 非常重要并且超出了本教程\
的范围 。 

API
==============================================================================

关联数组是无序键值对的集合 。 不允许使用重复的 Key 。 支持以下操作 ： 

- ``search(a, k)`` : 从关联数组 ``a`` 中返回与键 ``k`` 关联的值 ``v`` ， 如果键不\
  存在 ， 则返回 ``NULL`` 。
- ``insert(a, k, v)`` : 将 ``k:v`` 对存储在关联数组 ``a`` 中 。 
- ``delete(a, k)`` : 删除与 ``k`` 关联的 ``k:v`` 对 ， 如果 ``k`` 不存在 ， 则不\
  执行任何操作 。 

Setup
==============================================================================

要在您的计算机上设置 C ， 请参阅 《`Build Your Own Lisp`_》 一书中 Daniel Holden \
的 `指南`_ 。 Build Your Own Lisp 是一本好书 ， 我建议你通读它 。 

.. _`Build Your Own Lisp`: http://www.buildyourownlisp.com/chapter2_installation
.. _`指南`: https://github.com/jamesroutley/write-a-hash-table/blob/master/orangeduck

Code structure
==============================================================================

代码应放在以下目录结构中 : 

.. code-block:: bash 

    .
    ├── build
    └── src
        ├── hash_table.c
        ├── hash_table.h
        ├── prime.c
        └── prime.h

``src`` 将包含我们的代码 ， ``build`` 将包含我们编译的二进制文件 。 

术语
==============================================================================

有很多名称可以互换使用 。 在本文中 ， 我们将使用以下内容 ： 

- 关联数组 ： 实现上述 API_ 的抽象数据结构 。 也称为地图 、 符号表或字典 。 
- 哈希表 ： 使用哈希函数的关联数组 API 的快速实现 。 也称为哈希映射 、 映射 、 哈希\
  或字典 。 

关联数组可以用许多不同的底层数据结构来实现 。 可以通过简单地将项目存储在数组中并在搜\
索时遍历数组来实现 (不考虑性能) 。 关联数组和哈希表经常被混淆 ， 因为关联数组经常被\
实现为哈希表 。 

.. _API: #id16

下一节 ： 哈希表结构

******************************************************************************
02  哈希表结构
******************************************************************************

我们的键值对 (条目) 将每个都存储在一个结构中 ： 

.. code-block:: c 

    // hash_table.h
    typedef struct {
        char* key;
        char* value;
    } ht_item;

我们的哈希表存储了一个指向条目的指针数组 ， 以及一些关于它的大小和它是否装满的细节 ：

.. code-block:: C 

    // hash_table.h
    typedef struct {
        int size;
        int count;
        ht_item** items;
    } ht_hash_table;

初始化和删除
==============================================================================

我们需要为 ``ht_items`` 定义初始化函数 。 这个函数分配了一个与 ``ht_item`` 大小相\
当的内存块 ， 并在新的内存块中保存了字符串 ``k`` 和 ``v`` 的副本 。 这个函数被标记\
为静态的 ， 因为它只会被哈希表内部的代码调用 。 

.. code-block:: C 

    // hash_table.c
    #include <stdlib.h>
    #include <string.h>

    #include "hash_table.h"

    static ht_item* ht_new_item(const char* k, const char* v) {
        ht_item* i = malloc(sizeof(ht_item));
        i->key = strdup(k);
        i->value = strdup(v);
        return i;
    }

``ht_new`` 初始化一个新的哈希表 。 ``size`` 定义了我们可以存储多少个条目 。 目前固\
定为 53 。 我们将在有关 调整大小_ 的部分对此进行扩展 。 我们使用 calloc 初始化项目数组 \
， 它用 ``NULL`` 字节填充分配的内存 。 数组中的 ``NULL`` 条目表示该存储桶为空 。 

.. _调整大小: waiting

.. code-block:: C 

    // hash_table.c
    ht_hash_table* ht_new() {
        ht_hash_table* ht = malloc(sizeof(ht_hash_table));

        ht->size = 53;
        ht->count = 0;
        ht->items = calloc((size_t)ht->size, sizeof(ht_item*));
        return ht;
    }

